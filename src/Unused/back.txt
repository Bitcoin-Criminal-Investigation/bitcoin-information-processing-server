
#include <iostream>
#include <fstream>
#include "GetNode.hpp"

int main(){
	blocksci::Blockchain chain("/home/bitcoin-core/.blocksci/config.json");
	utility::string_t hash = U("fd2bb12808598dd1d6657638989b1f6a1646d24ee074d980ccfadefeb46bd4db");
	utility::string_t type = U("transaction");
	GetNode test(hash, type, chain);
	test.printNode();
	return 0;
}

GetNode:: GetNode(const utility::string_t &intarget, const utility::string_t &intype, blocksci::Blockchain &chain):chain(chain){
  hash = utility::conversions::to_utf8string(intarget);
	std::string t_type = utility::conversions::to_utf8string(intype);
	type = t_type;
	if(type == "wallet"){
    auto paddr = blocksci::getAddressFromString(hash, chain.getAccess());
		if(!paddr){
			throw std::runtime_error("Invalid Address");
		}
		waddress.insert(*paddr);
		wallet_target = *paddr;
    getWalletInfo(wallet_target);
  }else {
		try{
			blocksci::Transaction tx(hash, chain.getAccess());
			blocksci::Block stdTime = tx.block();
			txids.push_back(tx);
			setTime(stdTime.timestamp());
			getTxInfo(tx);
		}
    catch (const std::exception &e){
			throw e;
		}
  }
}

void GetNode::getWalletInfo(const blocksci::Address &rawAddress){
	blocksci::Transaction checkTransaction(hash, chain.getAccess());	
  for(const auto &txs : rawAddress.getTransactions()){
		if(tx_target == checkTransaction)
			return; // If requested item is transaction, which mean, this function is called at first time.

		blocksci::Block stdTime = txs.block();
		if(isIn3MonthsTransaction(stdTime.timestamp())){
			txids.push_back(txs);
			getTxInfo(txs);
		}
	}
}
void GetNode::getWalletInfo(const blocksci::Address &rawAddress, const blocksci::Transaction &pre_info){
	blocksci::Transaction checkTransaction(hash, chain.getAccess());	
  for(const auto &txs : rawAddress.getTransactions()){
		if(tx_target == checkTransaction)
			return; // If requested item is transaction, which mean, this function is called at first time.

		blocksci::Block stdTime = txs.block();
		if(isIn3MonthsTransaction(stdTime.timestamp())){
			if(find(txids.begin(), txids.end(), txs) != txids.end())
				return;
			txids.push_back(txs);
			getTxInfo(txs);
		}
	}
}

void GetNode::getTxInfo(const blocksci::Transaction& rtx){
	for(const auto &input : rtx.inputs()){
		blocksci::Address inputdata = input.getAddress();
		waddress.insert(inputdata);
		getWalletInfo(inputdata, rtx);
	}
	for(const auto &output : rtx.outputs()){
		blocksci::Address outputdata = output.getAddress();
		waddress.insert(outputdata);
		getWalletInfo(outputdata, rtx);
	}
	
}
void GetNode::setTime(time_t blockTime){
	aftertime = blockTime + DTIME / 2;
	beforetime = blockTime - DTIME / 2;
}
bool GetNode::isIn3MonthsTransaction(time_t blockTime){
  if(type == "wallet"){
		time_t current = std::time(nullptr);
 		time_t dest = current - DTIME;
	  return blockTime >= dest;
	}
	else{
		return blockTime >= beforetime && blockTime <= aftertime;
	}
}

void GetNode::printNode(){
	std::ofstream outFile("./result.txt");

	if(type == "wallet"){
		std::cout << "You Searched 'Wallet' type hash...." << std::endl;
		std::cout << "What you researched : " << hash << std::endl;
		outFile << "You Searched 'Wallet' type hash...." << std::endl;
		outFile << "What you researched : " << hash << std::endl;
	} else{
		std::cout << "You Searched 'Transaction' type hash...." << std::endl;
		std::cout << "What you researched : " << hash << std::endl;
		outFile << "You Searched 'Transaction' type hash...." << std::endl;
		outFile << "What you researched : " << hash << std::endl;
	}
	std::cout << "Wallets >> " << std::endl;
	outFile << "Wallet >> " << std::endl;
	for(const auto &v : waddress) {
		std::cout << v.toString() << std::endl;
		outFile << v.toString() << std::endl;
	}
	std::cout << std::endl;
	std::cout << "======================================" << std::endl;
	std::cout << "Transactions >> " << std::endl;

	outFile << std::endl;
	outFile << "=========================================" << std::endl;
	outFile << "Transactions >> " << std::endl;
	for(const auto &v : txids) {
		std::cout << v.toString() << std::endl;
		outFile << v.toString() << std::endl;
	}
	outFile.close();
	std::cout << std::endl;
}
