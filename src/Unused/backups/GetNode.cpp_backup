
#include <iostream>
#include "GetNode.hpp"

int main()
{
	blocksci::Blockchain chain("/home/bitcoin-core/.blocksci/config.json");
	utility::string_t hash = U("1DzVu4hXohWLVDuqpfN41Fw8SSNnbpmGL6");
	utility::string_t type = U("wallet");
	GetNode test(hash, type, chain);
	test.printNode();
	return 0;
}

GetNode::GetNode(const utility::string_t &intarget, const utility::string_t &intype, blocksci::Blockchain &chain) : chain(chain)
{
	hash = utility::conversions::to_utf8string(intarget);
	type = utility::conversions::to_utf8string(intype);
	if (type == "wallet")
	{
		auto paddr = blocksci::getAddressFromString(hash, chain.getAccess());
		if (!paddr)
		{
			throw std::runtime_error("Invalid Address");
		}
		waddress.insert(*paddr);
		getWalletInfo(*paddr);
	}
	else
	{
		try
		{
			blocksci::Transaction tx(hash, chain.getAccess());
			blocksci::Block stdTime = tx.block();
			tx_target = tx;
			txids.push_back(tx);
			setTime(stdTime.timestamp());
			getTxInfo(tx);
		}
		catch (const std::exception &e)
		{
			throw e;
		}
	}
}

void GetNode::getWalletInfo(const blocksci::Address &rawAddress)
{

	for (const auto &txs : rawAddress.getTransactions())
	{
		if (isIn3MonthsTransaction(txs.block().timestamp()))
		{
			txids.push_back(txs);
			getTxInfo(txs);
		}
	}
}
void GetNode::getWalletInfo(const blocksci::Address &rawAddress, const blocksci::Transaction &pre_info)
{
	for (const auto &txs : rawAddress.getTransactions())
	{
		if (pre_info.getHash().GetHex() == txs.getHash().GetHex())
			continue;

		if (isIn3MonthsTransaction(txs.block().timestamp()))
		{
			txids.push_back(txs);
			getTxInfo(txs);
		}
	}
}

void GetNode::getTxInfo(const blocksci::Transaction &rtx)
{
	for (const auto &input : rtx.inputs())
	{
		blocksci::Address inputdata = input.getAddress();
		waddress.insert(inputdata);
		getWalletInfo(inputdata, rtx);
	}
	for (const auto &output : rtx.outputs())
	{
		blocksci::Address outputdata = output.getAddress();
		waddress.insert(outputdata);
		getWalletInfo(outputdata, rtx);
	}
}

void GetNode::setTime(time_t blockTime)
{
	aftertime = blockTime + DTIME / 2;
	beforetime = blockTime - DTIME / 2;
}
bool GetNode::isIn3MonthsTransaction(time_t blockTime)
{
	if (type == "wallet")
	{
		time_t current = std::time(nullptr);
		time_t dest = current - DTIME;
		return blockTime >= dest;
	}
	else
	{
		return blockTime >= beforetime && blockTime <= aftertime;
	}
}

void GetNode::printNode()
{
	if (type == "wallet")
	{
		std::cout << "You Searched 'Wallet' type hash...." << std::endl;
		std::cout << "What you researched : " << hash << std::endl;
	}
	else
	{
		std::cout << "You Searched 'Transaction' type hash...." << std::endl;
		std::cout << "What you researched : " << hash << std::endl;
	}
	std::cout << "Wallets >> " << std::endl;
	for (const auto &v : waddress)
	{
		std::cout << v.toString() << std::endl;
	}
	std::cout << std::endl;
	std::cout << "======================================" << std::endl;
	std::cout << "Transactions >> " << std::endl;
	for (const auto &v : txids)
	{
		std::cout << v.getHash().GetHex() << std::endl;
	}
	std::cout << std::endl;
}